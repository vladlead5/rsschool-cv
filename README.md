# Битовые множества

## Битовые операции
В языке Си можно оперировать не только арифметическими операциями, но и битовыми.

### `Битовый ИЛИ`
Таблица истинности:  

| X | Y | X \| Y |
|----------|----------|----------|
| 0    | 0   | 0   |
| 0    | 1   | 1   |
| 1    | 0   | 1   |
| 1    | 1   | 1   |

Очень любим единицы.

### `Битовый И`
Таблица истинности:  

| X | Y | X & Y |
|----------|----------|----------|
| 0    | 0   | 0   |
| 0    | 1   | 0   |
| 1    | 0   | 0   |
| 1    | 1   | 1   |

Очень любим нули.

### `Битовый реверс`
Таблица истинности:  

| X | ~X |
|----------|----------|
| 0    | 1   |
| 1    | 0   |

Любим противоположное.

### `XOR`
Таблица истинности:  

| X | Y | X ^ Y |
|----------|----------|----------|
| 0    | 0   | 0   |
| 0    | 1   | 1   |
| 1    | 0   | 1   |
| 1    | 1   | 0   |

Очень любим различия.

---

К слову, при помощи XOR можно выполнить swap двух чисел без вспомогательной переменной. Попробуйте разобраться как работает код ниже:
```c
void swap(int32_t* a, int32_t* b){
    *a = *a ^ *b;
    *b = *b ^ *a;
    *a = *a ^ *b;
} // Не обращайте внимание на символ *, если не понимаете, зачем он тут используется.
```

### `Арифметический сдвиг`
Мы можем сдвинуть бит числа:
```c
int32_t a = 10; // 000...001010 in binary
int32_t b = a >> 1; // Сдвинуть вправо на 1
printf("%d\n", b); // Напечатается 5: 000...000101
b = a << 2; // Сдвинуть влево на 2
printf("%d\n", b); // Напечатается 20: 000...010100
```

## Немного чёрной магии
При помощи битовой арифметики можно делать кучу интересных вещей. 

Рекомендую руками позапускать код ниже. Для наглядности используйте функцию распечатки числа в бинарном виде:
```c
void printBits(size_t const size, void const * const ptr)
{
    unsigned char *b = (unsigned char*) ptr;
    unsigned char byte;
    size_t i, j;
    
    for (i = size-1; i >= 0; i--) {
        for (j = 7; j >= 0; j--) {
            byte = (b[i] >> j) & 1;
            printf("%u", byte);
        }
    }
    puts("");
}

int main(){
    int32_t i = 23;
    printBits(sizeof(i), &i); // USAGE
}
```

### `Функция abs`
```c
uint32_t abs(int32_t x){
    return (x + (x >> 31)) ^ (x >> 31);
}
```

### `Функция sign`
-1, если x < 0,  
0, если x = 0,  
1, если x > 0.
```c
int32_t sign(int32_t x){
    return (x > 0) - (x < 0);
}
```

### `Трехзначное сравнение`
-1, если x < y,  
0, если x = y,  
1, если x > y.  
```c
int32_t cmp(int32_t x, int32_t y){
    return (x > y) - (x < y);
}
```

### `Сравнение`
Можно даже реализовать булевское сравнение. Например:
```c
x == y -> ~(x - y | y - x);
```
---

К сожалению, эти конструкции малопонятны, выглядят как чёрная магия. А для чёрных магов, как подсказывает нам история, существовала инквизиция. Потому не советую использовать это в коде.
> Однако, согласитесь, выглядит красиво

## BitSet
Множества по определению подразумевает уникальные значения. При помощи операций выше, мы можем хранить множества букв в одной переменной int.

Оперировать лучше **unsigned int**, чтобы не напороться на особую работу с знаковым битом.

Предположим, у нас английский алфавит. В нём 27 букв. **int** занимает 32 бита. Давайте скажем, что если на n-ой позиции стоит единица, то соответствующая по порядку буква в алфавите присутствует в множестве.  
`Например`:
```c
a = 0
b = 1
c = 2
d = 3
...
z = 26

uint32_t Set = 5; // 000...00101 Означает, что множество состоит из a и c
```

### Как создать такое множество?
Попробуем руками заполнить множество из примера выше:
```c
char text[] = {'a', 'c'};
uint32_t Set = 0; // изначально пустое
for (int i = 0; i < strlen(text); ++i)
    Set = Set | (1u << (text[i] - 'a'))
```

- [Прочитайте](https://www.industrialnets.ru/files/misc/ascii.pdf) про аски таблицу, которая кодирует символы в числа.
```
Для символа 'a'
Set = Set | (1 << ('a' - 'a'))
Символу 'a' соответствует число 97 в аски.
Очнвидно, что (97 - 97) = 0.
Set = Set | (1 << 0)
Сдвигаем единицу на 0, т.е. получаем 000...001
Set = 0 | 1
Получаем 1: 000...001

Для символа 'c'
Set = Set | (1 << ('c' - 'a'))
Символу 'c' соответствует число 99 в аски.
Очнвидно, что (99 - 97) = 2.
Set = Set | (1 << 2)
Сдвигаем единицу на 2, т.е. получаем 000...100 = 4
Set = 1 | 4

in Binary:
000...0001
|
000...0100
Получаем 5: 000...0101
```

Очевидно, что если в массиве встретится ещё один символ `'c'`, то при логическом ИЛИ он никак не повлияет на множество.


## Задание

На вход подаются слова, разделёнными произвольными символами в произвольном количестве. Словом считается любая последовательность букв латинского алфавита, большего или малого регистра.

Вам необходимо решить задачу вашего варианта. Свой вариант можно найти [тут](variants.md).

## Важные требования к решению
Чтобы получить максимальный балл за задачу, необходимо удовлетворять следующим критериям:
- Запрещается хранить входные данные в массиве.
- Используется bitset.
- Обрабатываются все входные данные, предусмотренные заданием.
- Код должен быть понятным, названия переменных отражают то, что они хранят.
